| **Tree Type**                | **Balance**    | **Properties**                                                                                                   | **Insert Time Complexity**  | **Delete Time Complexity**  | **Search Time Complexity**  | **Use Case Example**                                      |
| ---------------------------- | -------------- | ---------------------------------------------------------------------------------------------------------------- | --------------------------- | --------------------------- | --------------------------- | --------------------------------------------------------- |
| **Binary Tree (BT)**         | Unbalanced     | - Each node has at most two children.<br>- No specific order or structure for data.                              | O(n)                        | O(n)                        | O(n)                        | General-purpose, expression trees, Huffman coding         |
| **Binary Search Tree (BST)** | Unbalanced     | - Left child < Parent < Right child.<br>- Efficient for sorted data.                                             | O(n) (worst case)           | O(n) (worst case)           | O(n) (worst case)           | Searching, sorting, dictionary implementations            |
| **AVL Tree**                 | Self-balancing | - Height difference between subtrees is at most 1.<br>- Rotations to maintain balance after inserts/deletes.     | O(log n)                    | O(log n)                    | O(log n)                    | Frequent insertions/deletions, self-balancing requirement |
| **Red-Black Tree**           | Self-balancing | - Each node has a color (Red or Black).<br>- Maintains balance with color rules (not as strict as AVL).          | O(log n)                    | O(log n)                    | O(log n)                    | Databases, operating systems (e.g., C++ STL maps/sets)    |
| **B-tree**                   | Self-balancing | - Nodes can have more than two children.<br>- All leaf nodes are at the same level.                              | O(log n)                    | O(log n)                    | O(log n)                    | Databases, file systems, indexing large datasets          |
| **B+ Tree**                  | Self-balancing | - All data stored at the leaves.<br>- Internal nodes guide the search.<br>- Leaves are linked for range queries. | O(log n)                    | O(log n)                    | O(log n)                    | Database indexing, range queries                          |
| **Heap (Binary Heap)**       | Complete       | - A complete binary tree.<br>- Max-heap or Min-heap (parent greater/less than children).                         | O(log n)                    | O(log n)                    | O(n)                        | Priority queues, heapsort                                 |
| **Trie**                     | Unbalanced     | - Each node represents a character of a string.<br>- Efficient for string matching and prefix searching.         | O(m) (m = length of string) | O(m) (m = length of string) | O(m) (m = length of string) | Autocomplete, IP routing, dictionary lookup               |
| **Segment Tree**             | Unbalanced     | - Efficient for range queries on intervals.<br>- Built on array segments.                                        | O(log n)                    | O(log n)                    | O(log n)                    | Range queries (sum, min, max), interval queries           |
| **Fenwick Tree (BIT)**       | Unbalanced     | - Stores cumulative frequency.<br>- Efficient for dynamic range sum queries.                                     | O(log n)                    | O(log n)                    | O(log n)                    | Cumulative frequency tables, range sum queries            |
